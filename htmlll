<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demo: Bisa Berpindah-pindah (Carousel + Draggable)</title>
</style>
</head>
<body>

<div class="card" aria-label="carousel-card">
  <h1>Carousel: Geser / Klik / Swipe</h1>
  <div class="carousel-wrap" id="carouselWrap">
    <div class="carousel" id="carousel">
      <div class="slide">Slide 1 — Selamat datang! (Konten bisa apa saja)</div>
      <div class="slide">Slide 2 — Ini contoh slide kedua</div>
      <div class="slide">Slide 3 — Slide ketiga, selesai</div>
    </div>
  </div>

  <div class="controls">
    <div>
      <button class="btn" id="prevBtn" aria-label="Previous">Prev</button>
      <button class="btn" id="nextBtn" aria-label="Next">Next</button>
    </div>
    <div class="dots" id="dots"></div>
  </div>
</div>

<div class="card" aria-label="draggable-card">
  <h1>Draggable: Geser kotak ini</h1>
  <div class="drag-area" id="dragArea">
    <div class="draggable" id="draggable" role="button" tabindex="0">Seret aku</div>
  </div>
  <p style="margin:10px 0 0;font-size:13px;color:#346;">(Bisa pakai mouse atau sentuhan. Kotak dibatasi area di atas.)</p>
</div>

<script>
  /* ====== Carousel logic with touch support ====== */
  (function(){
    const carousel = document.getElementById('carousel');
    const wrap = document.getElementById('carouselWrap');
    const slides = carousel.children;
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const dotsContainer = document.getElementById('dots');
    let index = 0, startX = null, isDragging = false, width = wrap.clientWidth;

    // create dots
    for(let i=0;i<slides.length;i++){
      const d = document.createElement('div');
      d.className='dot' + (i===0?' active':'');
      d.dataset.i = i;
      d.addEventListener('click', ()=> goTo(i));
      dotsContainer.appendChild(d);
    }

    function update(){
      width = wrap.clientWidth;
      carousel.style.transform = `translateX(${-index * width}px)`;
      // update dots
      Array.from(dotsContainer.children).forEach((d,i)=> d.classList.toggle('active', i===index));
      prevBtn.disabled = (index===0);
      nextBtn.disabled = (index===slides.length-1);
    }

    function goTo(i){ index = Math.max(0, Math.min(slides.length-1, i)); update(); }

    prevBtn.addEventListener('click', ()=> goTo(index-1));
    nextBtn.addEventListener('click', ()=> goTo(index+1));
    window.addEventListener('resize', update);

    // touch / drag for swipe
    wrap.addEventListener('touchstart', e => {
      startX = e.touches[0].clientX;
      isDragging = true;
    }, {passive:true});
    wrap.addEventListener('touchmove', e => {
      if(!isDragging) return;
      const dx = e.touches[0].clientX - startX;
      carousel.style.transition = 'none';
      carousel.style.transform = `translateX(${-index*width + dx}px)`;
    }, {passive:true});
    wrap.addEventListener('touchend', e => {
      carousel.style.transition = '';
      if(!isDragging) return;
      const dx = (e.changedTouches[0].clientX - startX);
      if(Math.abs(dx) > width*0.18){
        if(dx < 0) goTo(index+1); else goTo(index-1);
      } else {
        update();
      }
      isDragging = false;
      startX = null;
    });

    // mouse drag for desktop
    let mouseDown = false, mouseStart = 0;
    wrap.addEventListener('mousedown', e => { mouseDown=true; mouseStart = e.clientX; carousel.style.transition='none'; });
    window.addEventListener('mousemove', e => {
      if(!mouseDown) return;
      const dx = e.clientX - mouseStart;
      carousel.style.transform = `translateX(${-index*width + dx}px)`;
    });
    window.addEventListener('mouseup', e => {
      if(!mouseDown) return;
      const dx = e.clientX - mouseStart;
      carousel.style.transition = '';
      if(Math.abs(dx) > width*0.18) {
        if(dx < 0) goTo(index+1); else goTo(index-1);
      } else update();
      mouseDown=false;
    });

    // keyboard arrows
    window.addEventListener('keydown', e => {
      if(e.key === 'ArrowLeft') goTo(index-1);
      if(e.key === 'ArrowRight') goTo(index+1);
    });

    // initial layout
    update();
  })();

  /* ====== Draggable box (bounded to area) ====== */
  (function(){
    const drag = document.getElementById('draggable');
    const area = document.getElementById('dragArea');
    let active=false, startX=0, startY=0, origX=0, origY=0;

    // utility to keep inside bounds
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    function pointerDown(clientX, clientY){
      active = true;
      startX = clientX;
      startY = clientY;
      const rect = drag.getBoundingClientRect();
      const areaRect = area.getBoundingClientRect();
      origX = rect.left - areaRect.left;
      origY = rect.top - areaRect.top;
      drag.style.transition = 'none';
      drag.setPointerCapture && drag.setPointerCapture(event && event.pointerId);
    }

    function pointerMove(clientX, clientY){
      if(!active) return;
      const dx = clientX - startX;
      const dy = clientY - startY;
      const areaRect = area.getBoundingClientRect();
      const dRect = drag.getBoundingClientRect();
      const maxX = areaRect.width - dRect.width;
      const maxY = areaRect.height - dRect.height;
      const nx = clamp(origX + dx, 0, Math.max(0, maxX));
      const ny = clamp(origY + dy, 0, Math.max(0, maxY));
      drag.style.left = nx + 'px';
      drag.style.top = ny + 'px';
    }

    function pointerUp(){
      active=false;
      drag.style.transition = '';
    }

    // Mouse events
    drag.addEventListener('mousedown', e => { e.preventDefault(); pointerDown(e.clientX,e.clientY); });
    window.addEventListener('mousemove', e => pointerMove(e.clientX,e.clientY));
    window.addEventListener('mouseup', () => pointerUp());

    // Touch events
    drag.addEventListener('touchstart', e => { const t=e.touches[0]; pointerDown(t.clientX,t.clientY); }, {passive:false});
    window.addEventListener('touchmove', e => { if(!active) return; const t=e.touches[0]; pointerMove(t.clientX,t.clientY); }, {passive:false});
    window.addEventListener('touchend', pointerUp);

    // Make draggable focusable and move with keyboard arrows for accessibility
    drag.addEventListener('keydown', e => {
      const step = 10;
      const rect = drag.getBoundingClientRect();
      const areaRect = area.getBoundingClientRect();
      const dRect = drag.getBoundingClientRect();
      const maxX = areaRect.width - dRect.width;
      const maxY = areaRect.height - dRect.height;
      const curLeft = rect.left - areaRect.left;
      const curTop = rect.top - areaRect.top;
      if(e.key === 'ArrowLeft') { drag.style.left = clamp(curLeft - step, 0, maxX) + 'px'; e.preventDefault(); }
      if(e.key === 'ArrowRight') { drag.style.left = clamp(curLeft + step, 0, maxX) + 'px'; e.preventDefault(); }
      if(e.key === 'ArrowUp') { drag.style.top = clamp(curTop - step, 0, maxY) + 'px'; e.preventDefault(); }
      if(e.key === 'ArrowDown') { drag.style.top = clamp(curTop + step, 0, maxY) + 'px'; e.preventDefault(); }
    });

    // initialize position inside area in case styles differ
    window.addEventListener('load', () => {
      // ensure absolute positioned relative to area
      const areaRect = area.getBoundingClientRect();
      const dRect = drag.getBoundingClientRect();
      // convert current computed left/top if present
      drag.style.left = (parseFloat(getComputedStyle(drag).left) || 30) + 'px';
      drag.style.top = (parseFloat(getComputedStyle(drag).top) || 30) + 'px';
    });

  })();
</script>

</body>
</html>
