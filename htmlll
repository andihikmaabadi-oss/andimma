<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demo: Bisa Berpindah-pindah (Carousel + Draggable)</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{margin:0;background:#f3f6fb;color:#122;display:flex;flex-direction:column;align-items:center;gap:28px;padding:28px;min-height:100vh;box-sizing:border-box;}
  h1{margin:0 0 8px;font-size:20px;text-align:center;}
  .card{background:white;border-radius:12px;box-shadow:0 8px 24px rgba(10,20,40,0.08);padding:18px;max-width:900px;width:100%;}
  /* --- Carousel --- */
  .carousel-wrap{position:relative;overflow:hidden;border-radius:10px;}
  .carousel{display:flex;transition:transform .45s cubic-bezier(.22,.9,.28,1);will-change:transform;}
  .slide{min-width:100%;box-sizing:border-box;padding:28px;display:flex;align-items:center;justify-content:center;font-size:18px;height:220px;}
  .slide:nth-child(1){background:linear-gradient(135deg,#89f7fe 0%,#66a6ff 100%);color:#042;}
  .slide:nth-child(2){background:linear-gradient(135deg,#f6d365 0%,#fda085 100%);color:#2b0;}
  .slide:nth-child(3){background:linear-gradient(135deg,#cfd9df 0%,#e2ebf0 100%);color:#113;}
  .controls{display:flex;justify-content:space-between;gap:12px;margin-top:12px;}
  .btn{border:0;padding:8px 12px;border-radius:8px;background:#0b69ff;color:white;cursor:pointer;box-shadow:0 6px 16px rgba(11,105,255,0.18);}
  .btn:disabled{opacity:.45;cursor:not-allowed;box-shadow:none;}
  .dots{display:flex;gap:8px;align-items:center;}
  .dot{width:10px;height:10px;border-radius:50%;background:rgba(0,0,0,.12);cursor:pointer;}
  .dot.active{background:#0b69ff;transform:scale(1.12);}

  /* --- Draggable --- */
  .drag-area{position:relative;height:260px;border:2px dashed rgba(10,20,40,.06);display:flex;align-items:center;justify-content:center;margin-top:18px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,.6),transparent);}
  .draggable{position:absolute;left:30px;top:30px;width:120px;height:80px;background:#fffa;display:flex;align-items:center;justify-content:center;border-radius:10px;touch-action:none;cursor:grab;user-select:none;box-shadow:0 10px 30px rgba(10,20,40,0.08);font-weight:600;}
  .draggable:active{cursor:grabbing;transform:scale(.995);}

  /* small screens */
  @media (max-width:560px){
    .slide{height:180px;padding:16px;font-size:16px;}
    .draggable{width:100px;height:64px;}
  }
</style>
</head>
<body>

<div class="card" aria-label="carousel-card">
  <h1>Carousel: Geser / Klik / Swipe</h1>
  <div class="carousel-wrap" id="carouselWrap">
    <div class="carousel" id="carousel">
      <div class="slide">Slide 1 — Selamat datang! (Konten bisa apa saja)</div>
      <div class="slide">Slide 2 — Ini contoh slide kedua</div>
      <div class="slide">Slide 3 — Slide ketiga, selesai</div>
    </div>
  </div>

  <div class="controls">
    <div>
      <button class="btn" id="prevBtn" aria-label="Previous">Prev</button>
      <button class="btn" id="nextBtn" aria-label="Next">Next</button>
    </div>
    <div class="dots" id="dots"></div>
  </div>
</div>

<div class="card" aria-label="draggable-card">
  <h1>Draggable: Geser kotak ini</h1>
  <div class="drag-area" id="dragArea">
    <div class="draggable" id="draggable" role="button" tabindex="0">Seret aku</div>
  </div>
  <p style="margin:10px 0 0;font-size:13px;color:#346;">(Bisa pakai mouse atau sentuhan. Kotak dibatasi area di atas.)</p>
</div>

<script>
  /* ====== Carousel logic with touch support ====== */
  (function(){
    const carousel = document.getElementById('carousel');
    const wrap = document.getElementById('carouselWrap');
    const slides = carousel.children;
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const dotsContainer = document.getElementById('dots');
    let index = 0, startX = null, isDragging = false, width = wrap.clientWidth;

    // create dots
    for(let i=0;i<slides.length;i++){
      const d = document.createElement('div');
      d.className='dot' + (i===0?' active':'');
      d.dataset.i = i;
      d.addEventListener('click', ()=> goTo(i));
      dotsContainer.appendChild(d);
    }

    function update(){
      width = wrap.clientWidth;
      carousel.style.transform = `translateX(${-index * width}px)`;
      // update dots
      Array.from(dotsContainer.children).forEach((d,i)=> d.classList.toggle('active', i===index));
      prevBtn.disabled = (index===0);
      nextBtn.disabled = (index===slides.length-1);
    }

    function goTo(i){ index = Math.max(0, Math.min(slides.length-1, i)); update(); }

    prevBtn.addEventListener('click', ()=> goTo(index-1));
    nextBtn.addEventListener('click', ()=> goTo(index+1));
    window.addEventListener('resize', update);

    // touch / drag for swipe
    wrap.addEventListener('touchstart', e => {
      startX = e.touches[0].clientX;
      isDragging = true;
    }, {passive:true});
    wrap.addEventListener('touchmove', e => {
      if(!isDragging) return;
      const dx = e.touches[0].clientX - startX;
      carousel.style.transition = 'none';
      carousel.style.transform = `translateX(${-index*width + dx}px)`;
    }, {passive:true});
    wrap.addEventListener('touchend', e => {
      carousel.style.transition = '';
      if(!isDragging) return;
      const dx = (e.changedTouches[0].clientX - startX);
      if(Math.abs(dx) > width*0.18){
        if(dx < 0) goTo(index+1); else goTo(index-1);
      } else {
        update();
      }
      isDragging = false;
      startX = null;
    });

    // mouse drag for desktop
    let mouseDown = false, mouseStart = 0;
    wrap.addEventListener('mousedown', e => { mouseDown=true; mouseStart = e.clientX; carousel.style.transition='none'; });
    window.addEventListener('mousemove', e => {
      if(!mouseDown) return;
      const dx = e.clientX - mouseStart;
      carousel.style.transform = `translateX(${-index*width + dx}px)`;
    });
    window.addEventListener('mouseup', e => {
      if(!mouseDown) return;
      const dx = e.clientX - mouseStart;
      carousel.style.transition = '';
      if(Math.abs(dx) > width*0.18) {
        if(dx < 0) goTo(index+1); else goTo(index-1);
      } else update();
      mouseDown=false;
    });

    // keyboard arrows
    window.addEventListener('keydown', e => {
      if(e.key === 'ArrowLeft') goTo(index-1);
      if(e.key === 'ArrowRight') goTo(index+1);
    });

    // initial layout
    update();
  })();

  /* ====== Draggable box (bounded to area) ====== */
  (function(){
    const drag = document.getElementById('draggable');
    const area = document.getElementById('dragArea');
    let active=false, startX=0, startY=0, origX=0, origY=0;

    // utility to keep inside bounds
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    function pointerDown(clientX, clientY){
      active = true;
      startX = clientX;
      startY = clientY;
      const rect = drag.getBoundingClientRect();
      const areaRect = area.getBoundingClientRect();
      origX = rect.left - areaRect.left;
      origY = rect.top - areaRect.top;
      drag.style.transition = 'none';
      drag.setPointerCapture && drag.setPointerCapture(event && event.pointerId);
    }

    function pointerMove(clientX, clientY){
      if(!active) return;
      const dx = clientX - startX;
      const dy = clientY - startY;
      const areaRect = area.getBoundingClientRect();
      const dRect = drag.getBoundingClientRect();
      const maxX = areaRect.width - dRect.width;
      const maxY = areaRect.height - dRect.height;
      const nx = clamp(origX + dx, 0, Math.max(0, maxX));
      const ny = clamp(origY + dy, 0, Math.max(0, maxY));
      drag.style.left = nx + 'px';
      drag.style.top = ny + 'px';
    }

    function pointerUp(){
      active=false;
      drag.style.transition = '';
    }

    // Mouse events
    drag.addEventListener('mousedown', e => { e.preventDefault(); pointerDown(e.clientX,e.clientY); });
    window.addEventListener('mousemove', e => pointerMove(e.clientX,e.clientY));
    window.addEventListener('mouseup', () => pointerUp());

    // Touch events
    drag.addEventListener('touchstart', e => { const t=e.touches[0]; pointerDown(t.clientX,t.clientY); }, {passive:false});
    window.addEventListener('touchmove', e => { if(!active) return; const t=e.touches[0]; pointerMove(t.clientX,t.clientY); }, {passive:false});
    window.addEventListener('touchend', pointerUp);

    // Make draggable focusable and move with keyboard arrows for accessibility
    drag.addEventListener('keydown', e => {
      const step = 10;
      const rect = drag.getBoundingClientRect();
      const areaRect = area.getBoundingClientRect();
      const dRect = drag.getBoundingClientRect();
      const maxX = areaRect.width - dRect.width;
      const maxY = areaRect.height - dRect.height;
      const curLeft = rect.left - areaRect.left;
      const curTop = rect.top - areaRect.top;
      if(e.key === 'ArrowLeft') { drag.style.left = clamp(curLeft - step, 0, maxX) + 'px'; e.preventDefault(); }
      if(e.key === 'ArrowRight') { drag.style.left = clamp(curLeft + step, 0, maxX) + 'px'; e.preventDefault(); }
      if(e.key === 'ArrowUp') { drag.style.top = clamp(curTop - step, 0, maxY) + 'px'; e.preventDefault(); }
      if(e.key === 'ArrowDown') { drag.style.top = clamp(curTop + step, 0, maxY) + 'px'; e.preventDefault(); }
    });

    // initialize position inside area in case styles differ
    window.addEventListener('load', () => {
      // ensure absolute positioned relative to area
      const areaRect = area.getBoundingClientRect();
      const dRect = drag.getBoundingClientRect();
      // convert current computed left/top if present
      drag.style.left = (parseFloat(getComputedStyle(drag).left) || 30) + 'px';
      drag.style.top = (parseFloat(getComputedStyle(drag).top) || 30) + 'px';
    });

  })();
</script>

</body>
</html>
